// Autogenerated from Pigeon (v25.2.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Holder
///
/// Generated class from Pigeon that represents data sent in messages.
struct IOSOnDemandResourcesPigeon {
  /// Map from a On-Demand Resource Tag to its Resource
  var resourceMap: [String: IOSOnDemandResourcePigeon]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> IOSOnDemandResourcesPigeon? {
    let resourceMap = pigeonVar_list[0] as! [String: IOSOnDemandResourcePigeon]

    return IOSOnDemandResourcesPigeon(
      resourceMap: resourceMap
    )
  }
  func toList() -> [Any?] {
    return [
      resourceMap
    ]
  }
}

/// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest
///
/// Generated class from Pigeon that represents data sent in messages.
struct IOSOnDemandResourcePigeon {
  var tag: String
  /// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/1614840-beginaccessingresources
  var error: IOSNSErrorPigeon? = nil
  /// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/1614834-conditionallybeginaccessingresou
  var condition: Bool
  /// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/1614841-loadingpriority
  var loadingPriority: Double
  /// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/1614838-progress
  var progress: IOSProgressPigeon


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> IOSOnDemandResourcePigeon? {
    let tag = pigeonVar_list[0] as! String
    let error: IOSNSErrorPigeon? = nilOrValue(pigeonVar_list[1])
    let condition = pigeonVar_list[2] as! Bool
    let loadingPriority = pigeonVar_list[3] as! Double
    let progress = pigeonVar_list[4] as! IOSProgressPigeon

    return IOSOnDemandResourcePigeon(
      tag: tag,
      error: error,
      condition: condition,
      loadingPriority: loadingPriority,
      progress: progress
    )
  }
  func toList() -> [Any?] {
    return [
      tag,
      error,
      condition,
      loadingPriority,
      progress,
    ]
  }
}

/// https://developer.apple.com/documentation/foundation/nserror
///
/// Generated class from Pigeon that represents data sent in messages.
struct IOSNSErrorPigeon {
  var code: Int64
  var domain: String
  var localizedDescription: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> IOSNSErrorPigeon? {
    let code = pigeonVar_list[0] as! Int64
    let domain = pigeonVar_list[1] as! String
    let localizedDescription = pigeonVar_list[2] as! String

    return IOSNSErrorPigeon(
      code: code,
      domain: domain,
      localizedDescription: localizedDescription
    )
  }
  func toList() -> [Any?] {
    return [
      code,
      domain,
      localizedDescription,
    ]
  }
}

/// https://developer.apple.com/documentation/foundation/progress
///
/// Generated class from Pigeon that represents data sent in messages.
struct IOSProgressPigeon {
  var isCancelled: Bool
  var isPaused: Bool
  var fractionCompleted: Double
  var isFinished: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> IOSProgressPigeon? {
    let isCancelled = pigeonVar_list[0] as! Bool
    let isPaused = pigeonVar_list[1] as! Bool
    let fractionCompleted = pigeonVar_list[2] as! Double
    let isFinished = pigeonVar_list[3] as! Bool

    return IOSProgressPigeon(
      isCancelled: isCancelled,
      isPaused: isPaused,
      fractionCompleted: fractionCompleted,
      isFinished: isFinished
    )
  }
  func toList() -> [Any?] {
    return [
      isCancelled,
      isPaused,
      fractionCompleted,
      isFinished,
    ]
  }
}

private class OnDemandResourcesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      return IOSOnDemandResourcesPigeon.fromList(self.readValue() as! [Any?])
    case 130:
      return IOSOnDemandResourcePigeon.fromList(self.readValue() as! [Any?])
    case 131:
      return IOSNSErrorPigeon.fromList(self.readValue() as! [Any?])
    case 132:
      return IOSProgressPigeon.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class OnDemandResourcesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? IOSOnDemandResourcesPigeon {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? IOSOnDemandResourcePigeon {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? IOSNSErrorPigeon {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? IOSProgressPigeon {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class OnDemandResourcesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return OnDemandResourcesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return OnDemandResourcesPigeonCodecWriter(data: data)
  }
}

class OnDemandResourcesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = OnDemandResourcesPigeonCodec(readerWriter: OnDemandResourcesPigeonCodecReaderWriter())
}

var onDemandResourcesPigeonMethodCodec = FlutterStandardMethodCodec(readerWriter: OnDemandResourcesPigeonCodecReaderWriter());



private class PigeonStreamHandler<ReturnType>: NSObject, FlutterStreamHandler {
  private let wrapper: PigeonEventChannelWrapper<ReturnType>
  private var pigeonSink: PigeonEventSink<ReturnType>? = nil

  init(wrapper: PigeonEventChannelWrapper<ReturnType>) {
    self.wrapper = wrapper
  }

  func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink)
    -> FlutterError?
  {
    pigeonSink = PigeonEventSink<ReturnType>(events)
    wrapper.onListen(withArguments: arguments, sink: pigeonSink!)
    return nil
  }

  func onCancel(withArguments arguments: Any?) -> FlutterError? {
    pigeonSink = nil
    wrapper.onCancel(withArguments: arguments)
    return nil
  }
}

class PigeonEventChannelWrapper<ReturnType> {
  func onListen(withArguments arguments: Any?, sink: PigeonEventSink<ReturnType>) {}
  func onCancel(withArguments arguments: Any?) {}
}

class PigeonEventSink<ReturnType> {
  private let sink: FlutterEventSink

  init(_ sink: @escaping FlutterEventSink) {
    self.sink = sink
  }

  func success(_ value: ReturnType) {
    sink(value)
  }

  func error(code: String, message: String?, details: Any?) {
    sink(FlutterError(code: code, message: message, details: details))
  }

  func endOfStream() {
    sink(FlutterEndOfEventStream)
  }

}

class StreamOnDemandResourceStreamHandler: PigeonEventChannelWrapper<IOSOnDemandResourcePigeon> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: StreamOnDemandResourceStreamHandler) {
    var channelName = "dev.flutter.pigeon.online_assets.OnDemandResourcesEventChannelApi.streamOnDemandResource"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<IOSOnDemandResourcePigeon>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: onDemandResourcesPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol OnDemandResourcesHostApi {
  func requestResourcesProgress(tags: [String], completion: @escaping (Result<IOSOnDemandResourcesPigeon, Error>) -> Void)
  func beginAccessingResources(tags: [String], completion: @escaping (Result<IOSOnDemandResourcesPigeon, Error>) -> Void)
  /// Get the path to the copy of the iOS Asset file.
  ///
  /// It is not possible to obtain the file path of the asset file itself.
  /// Therefore, the path of the file copied to temporary directory is obtained.
  ///
  /// If the file is still in the temporary folder when this function is called and the file size is the same as the asset, file is reused.
  /// Therefore, if an asset is replaced by app update, and the file size is exactly the same but the contents are different, there is a problem that the previous file will be used.
  /// In this case, use the [deleteCopiedAssetFile] function.
  /// However, the possibility that the file contents are different and the file size is exactly the same is quite small, so you do not need to worry too much about it.
  ///
  /// If [tag] == [null], access is made to standard iOS assets that is not On-Demand Resources.
  ///
  /// Note that using this function uses twice as much device storage due to the assets of the system and the copied files.
  /// The copied files and on-demand resource files will be deleted by system when storage space is running low due to temporary files, but will be copied or downloaded again on use.
  ///
  /// The reason for including the tag namespace in the asset name is so that there is no conflict if the name is same with other asset packs.
  func getCopiedAssetFilePath(tag: String?, assetName: String, ext: String, completion: @escaping (Result<String?, Error>) -> Void)
  /// Delete the copied asset file.
  ///
  /// Returns true if the target file or folder was successfully deleted.
  /// Also returns true if the target file or folder does not yet exist.
  ///
  /// If the file is still in the temporary folder when [getCopiedAssetFilePath] function is called and the file size is the same as the asset, file is reused.
  /// Therefore, if an asset is replaced by app update, and the file size is exactly the same but the contents are different, there is a problem that the previous file will be used.
  /// If you want to avoid this case, you call delete function when your app update.
  /// However, the possibility that the file contents are different and the file size is exactly the same is quite small, so you do not need to worry too much about it.
  func deleteCopiedAssetFile(assetName: String, ext: String, completion: @escaping (Result<Bool, Error>) -> Void)
  func deleteCopiedAssetFolder(packName: String, completion: @escaping (Result<Bool, Error>) -> Void)
  func deleteAllCopiedAssetFolders(completion: @escaping (Result<Bool, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class OnDemandResourcesHostApiSetup {
  static var codec: FlutterStandardMessageCodec { OnDemandResourcesPigeonCodec.shared }
  /// Sets up an instance of `OnDemandResourcesHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: OnDemandResourcesHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let requestResourcesProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.requestResourcesProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestResourcesProgressChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tagsArg = args[0] as! [String]
        api.requestResourcesProgress(tags: tagsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      requestResourcesProgressChannel.setMessageHandler(nil)
    }
    let beginAccessingResourcesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.beginAccessingResources\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      beginAccessingResourcesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tagsArg = args[0] as! [String]
        api.beginAccessingResources(tags: tagsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      beginAccessingResourcesChannel.setMessageHandler(nil)
    }
    /// Get the path to the copy of the iOS Asset file.
    ///
    /// It is not possible to obtain the file path of the asset file itself.
    /// Therefore, the path of the file copied to temporary directory is obtained.
    ///
    /// If the file is still in the temporary folder when this function is called and the file size is the same as the asset, file is reused.
    /// Therefore, if an asset is replaced by app update, and the file size is exactly the same but the contents are different, there is a problem that the previous file will be used.
    /// In this case, use the [deleteCopiedAssetFile] function.
    /// However, the possibility that the file contents are different and the file size is exactly the same is quite small, so you do not need to worry too much about it.
    ///
    /// If [tag] == [null], access is made to standard iOS assets that is not On-Demand Resources.
    ///
    /// Note that using this function uses twice as much device storage due to the assets of the system and the copied files.
    /// The copied files and on-demand resource files will be deleted by system when storage space is running low due to temporary files, but will be copied or downloaded again on use.
    ///
    /// The reason for including the tag namespace in the asset name is so that there is no conflict if the name is same with other asset packs.
    let getCopiedAssetFilePathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.getCopiedAssetFilePath\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCopiedAssetFilePathChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tagArg: String? = nilOrValue(args[0])
        let assetNameArg = args[1] as! String
        let extArg = args[2] as! String
        api.getCopiedAssetFilePath(tag: tagArg, assetName: assetNameArg, ext: extArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCopiedAssetFilePathChannel.setMessageHandler(nil)
    }
    /// Delete the copied asset file.
    ///
    /// Returns true if the target file or folder was successfully deleted.
    /// Also returns true if the target file or folder does not yet exist.
    ///
    /// If the file is still in the temporary folder when [getCopiedAssetFilePath] function is called and the file size is the same as the asset, file is reused.
    /// Therefore, if an asset is replaced by app update, and the file size is exactly the same but the contents are different, there is a problem that the previous file will be used.
    /// If you want to avoid this case, you call delete function when your app update.
    /// However, the possibility that the file contents are different and the file size is exactly the same is quite small, so you do not need to worry too much about it.
    let deleteCopiedAssetFileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.deleteCopiedAssetFile\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteCopiedAssetFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let assetNameArg = args[0] as! String
        let extArg = args[1] as! String
        api.deleteCopiedAssetFile(assetName: assetNameArg, ext: extArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteCopiedAssetFileChannel.setMessageHandler(nil)
    }
    let deleteCopiedAssetFolderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.deleteCopiedAssetFolder\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteCopiedAssetFolderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let packNameArg = args[0] as! String
        api.deleteCopiedAssetFolder(packName: packNameArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteCopiedAssetFolderChannel.setMessageHandler(nil)
    }
    let deleteAllCopiedAssetFoldersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.deleteAllCopiedAssetFolders\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteAllCopiedAssetFoldersChannel.setMessageHandler { _, reply in
        api.deleteAllCopiedAssetFolders { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteAllCopiedAssetFoldersChannel.setMessageHandler(nil)
    }
  }
}
