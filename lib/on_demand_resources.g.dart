// Autogenerated from Pigeon (v25.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}
bool _deepEquals(Object? a, Object? b) {
  if (a is List && b is List) {
    return a.length == b.length &&
        a.indexed
        .every(((int, dynamic) item) => _deepEquals(item.$2, b[item.$1]));
  }
  if (a is Map && b is Map) {
    final Iterable<Object?> keys = (a as Map<Object?, Object?>).keys;
    return a.length == b.length && keys.every((Object? key) =>
        (b as Map<Object?, Object?>).containsKey(key) &&
        _deepEquals(a[key], b[key]));
  }
  return a == b;
}
    

/// Holder
class IOSOnDemandResourcesPigeon {
  IOSOnDemandResourcesPigeon({
    required this.resourceMap,
  });

  /// Map from a On-Demand Resource Tag to its Resource
  Map<String, IOSOnDemandResourcePigeon> resourceMap;

  List<Object?> _toList() {
    return <Object?>[
      resourceMap,
    ];
  }

  Object encode() {
    return _toList();  }

  static IOSOnDemandResourcesPigeon decode(Object result) {
    result as List<Object?>;
    return IOSOnDemandResourcesPigeon(
      resourceMap: (result[0] as Map<Object?, Object?>?)!.cast<String, IOSOnDemandResourcePigeon>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! IOSOnDemandResourcesPigeon || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return 
      _deepEquals(resourceMap, other.resourceMap);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest
class IOSOnDemandResourcePigeon {
  IOSOnDemandResourcePigeon({
    required this.tag,
    this.error,
    required this.condition,
    required this.loadingPriority,
    required this.progress,
  });

  String tag;

  /// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/1614840-beginaccessingresources
  IOSNSErrorPigeon? error;

  /// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/1614834-conditionallybeginaccessingresou
  bool condition;

  /// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/1614841-loadingpriority
  double loadingPriority;

  /// https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/1614838-progress
  IOSProgressPigeon progress;

  List<Object?> _toList() {
    return <Object?>[
      tag,
      error,
      condition,
      loadingPriority,
      progress,
    ];
  }

  Object encode() {
    return _toList();  }

  static IOSOnDemandResourcePigeon decode(Object result) {
    result as List<Object?>;
    return IOSOnDemandResourcePigeon(
      tag: result[0]! as String,
      error: result[1] as IOSNSErrorPigeon?,
      condition: result[2]! as bool,
      loadingPriority: result[3]! as double,
      progress: result[4]! as IOSProgressPigeon,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! IOSOnDemandResourcePigeon || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return 
      tag == other.tag
      && error == other.error
      && condition == other.condition
      && loadingPriority == other.loadingPriority
      && progress == other.progress;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// https://developer.apple.com/documentation/foundation/nserror
class IOSNSErrorPigeon {
  IOSNSErrorPigeon({
    required this.code,
    required this.domain,
    required this.localizedDescription,
  });

  int code;

  String domain;

  String localizedDescription;

  List<Object?> _toList() {
    return <Object?>[
      code,
      domain,
      localizedDescription,
    ];
  }

  Object encode() {
    return _toList();  }

  static IOSNSErrorPigeon decode(Object result) {
    result as List<Object?>;
    return IOSNSErrorPigeon(
      code: result[0]! as int,
      domain: result[1]! as String,
      localizedDescription: result[2]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! IOSNSErrorPigeon || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return 
      code == other.code
      && domain == other.domain
      && localizedDescription == other.localizedDescription;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// https://developer.apple.com/documentation/foundation/progress
class IOSProgressPigeon {
  IOSProgressPigeon({
    required this.isCancelled,
    required this.isPaused,
    required this.fractionCompleted,
    required this.isFinished,
  });

  bool isCancelled;

  bool isPaused;

  double fractionCompleted;

  bool isFinished;

  List<Object?> _toList() {
    return <Object?>[
      isCancelled,
      isPaused,
      fractionCompleted,
      isFinished,
    ];
  }

  Object encode() {
    return _toList();  }

  static IOSProgressPigeon decode(Object result) {
    result as List<Object?>;
    return IOSProgressPigeon(
      isCancelled: result[0]! as bool,
      isPaused: result[1]! as bool,
      fractionCompleted: result[2]! as double,
      isFinished: result[3]! as bool,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! IOSProgressPigeon || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return 
      isCancelled == other.isCancelled
      && isPaused == other.isPaused
      && fractionCompleted == other.fractionCompleted
      && isFinished == other.isFinished;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}


class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    }    else if (value is IOSOnDemandResourcesPigeon) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    }    else if (value is IOSOnDemandResourcePigeon) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    }    else if (value is IOSNSErrorPigeon) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    }    else if (value is IOSProgressPigeon) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129: 
        return IOSOnDemandResourcesPigeon.decode(readValue(buffer)!);
      case 130: 
        return IOSOnDemandResourcePigeon.decode(readValue(buffer)!);
      case 131: 
        return IOSNSErrorPigeon.decode(readValue(buffer)!);
      case 132: 
        return IOSProgressPigeon.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

const StandardMethodCodec pigeonMethodCodec = StandardMethodCodec(_PigeonCodec());

Stream<IOSOnDemandResourcePigeon> streamOnDemandResource( {String instanceName = ''}) {
  if (instanceName.isNotEmpty) {
    instanceName = '.$instanceName';
  }
  final EventChannel streamOnDemandResourceChannel =
      EventChannel('dev.flutter.pigeon.online_assets.OnDemandResourcesEventChannelApi.streamOnDemandResource$instanceName', pigeonMethodCodec);
  return streamOnDemandResourceChannel.receiveBroadcastStream().map((dynamic event) {
    return event as IOSOnDemandResourcePigeon;
  });
}
    

class OnDemandResourcesHostApi {
  /// Constructor for [OnDemandResourcesHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  OnDemandResourcesHostApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<IOSOnDemandResourcesPigeon> requestResourcesProgress({required List<String> tags}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.requestResourcesProgress$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(<Object?>[tags]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as IOSOnDemandResourcesPigeon?)!;
    }
  }

  Future<IOSOnDemandResourcesPigeon> beginAccessingResources({required List<String> tags}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.beginAccessingResources$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(<Object?>[tags]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as IOSOnDemandResourcesPigeon?)!;
    }
  }

  /// Get the path to the copy of the iOS Asset file.
  ///
  /// It is not possible to obtain the file path of the asset file itself.
  /// Therefore, the path of the file copied to temporary directory is obtained.
  ///
  /// If the file is still in the temporary folder when this function is called and the file size is the same as the asset, file is reused.
  /// Therefore, if an asset is replaced by app update, and the file size is exactly the same but the contents are different, there is a problem that the previous file will be used.
  /// In this case, use the [deleteCopiedAssetFile] function.
  /// However, the possibility that the file contents are different and the file size is exactly the same is quite small, so you do not need to worry too much about it.
  ///
  /// If [tag] == [null], access is made to standard iOS assets that is not On-Demand Resources.
  ///
  /// Note that using this function uses twice as much device storage due to the assets of the system and the copied files.
  /// The copied files and on-demand resource files will be deleted by system when storage space is running low due to temporary files, but will be copied or downloaded again on use.
  ///
  /// The reason for including the tag namespace in the asset name is so that there is no conflict if the name is same with other asset packs.
  Future<String?> getCopiedAssetFilePath({required String? tag, required String assetNameWithPackNameNamespace, required String ext, }) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.getCopiedAssetFilePath$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(<Object?>[tag, assetNameWithPackNameNamespace, ext]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  /// Delete the copied asset file.
  ///
  /// If [tag] == [null], delete standard iOS assets copied file that is not On-Demand Resources.
  ///
  /// Returns true if the target file or folder was successfully deleted.
  /// Also returns true if the target file or folder does not yet exist.
  ///
  /// If the file is still in the temporary folder when [getCopiedAssetFilePath] function is called and the file size is the same as the asset, file is reused.
  /// Therefore, if an asset is replaced by app update, and the file size is exactly the same but the contents are different, there is a problem that the previous file will be used.
  /// If you want to avoid this case, you call delete function when your app update.
  /// However, the possibility that the file contents are different and the file size is exactly the same is quite small, so you do not need to worry too much about it.
  Future<bool> deleteCopiedAssetFile({required String assetNameWithPackNameNamespace, required String ext}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.deleteCopiedAssetFile$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(<Object?>[assetNameWithPackNameNamespace, ext]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> deleteCopiedAssetFolder({required String packName}) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.deleteCopiedAssetFolder$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(<Object?>[packName]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> deleteAllCopiedAssetFolders() async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.online_assets.OnDemandResourcesHostApi.deleteAllCopiedAssetFolders$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }
}
